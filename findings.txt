As the basis of Docker, the containers share the machine's operating system kernel, and therefore it doesn't require a separate OS per service which provides better server efficiency and lower costs. By running `docker network ls`, it can be seen that containers share the host's network interfaces, but with `docker container ls`, it shows that they operate in isolated network namespaces. When service1's port 8199 is exposed, it maps a container's port to the host's network interface to allow external access, such as using the command `curl localhost:8199`.
File system data can be shared between the host and containers using volumes or bind mounts, but I didn't explicitly use volumes here, so each container has its own filesystem. The shared kernel is therefore responsible for accessing the hardware storage. Lastly, although containers run as separate processes, but these processes exist and shared in the host's process table, but they must have identical PIDs to not conflict with host PIDs. To conclude, containers share critical resources with the host, particularly the kernel, networking infrastructure, and PID namespace, while maintaining isolated file systems and process environments for security and modularity.